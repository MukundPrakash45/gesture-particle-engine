<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-feed { position: absolute; bottom: 20px; left: 20px; width: 320px; height: 240px; transform: scaleX(-1); border: 2px solid #333; z-index: 2; opacity: 0.8; border-radius: 8px; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 3; pointer-events: none; }
        h1 { margin: 0; font-size: 1.5rem; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        p { margin: 5px 0; font-size: 0.9rem; opacity: 0.8; }
        .status { color: #0f0; font-weight: bold; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: cyan; font-size: 2rem; z-index: 10; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initialize Camera & AI...</div>

    <div id="ui">
        <h1>Gesture Particles</h1>
        <p>üñê <b>Open Hand:</b> Disperse / Expand Particles</p>
        <p>‚úä <b>Fist (Pinch):</b> Collapse to Shape</p>
        <p>üëÜ <b>Move Hand:</b> Rotate & Move Shape</p>
        <p>Current Shape: <span id="shape-name" class="status">Sphere</span></p>
    </div>

    <video id="video-feed" playsinline></video>
    
    <div id="canvas-container"></div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 8000;
    const PARTICLE_SIZE = 0.15;
    const LERP_SPEED = 0.08;
    
    let scene, camera, renderer, particles, geometry, materials;
    let targetPositions = []; // The destination array for the current shape
    let currentPositions = []; // Where particles actually are
    
    // Interaction State
    let handPosition = { x: 0, y: 0, z: 0 };
    let isHandDetected = false;
    let isFist = false; // Trigger for "Collapse/Form Shape"
    let currentShapeIndex = 0;
    
    const SHAPES = ['Sphere', 'Heart', 'Saturn', 'Flower', 'Twist'];

    // --- INIT THREE.JS ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        
        scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Initialize Particle Geometry
        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        // Fill with random initial data
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
            
            colors[i * 3] = 1; 
            colors[i * 3 + 1] = 1;
            colors[i * 3 + 2] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create Material (Addative blending for glow effect)
        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Initialize targets array
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            currentPositions.push(positions[i]);
            targetPositions.push(positions[i]);
        }

        // Set initial shape
        setShape('Sphere');

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- SHAPE GENERATORS ---
    function setShape(type) {
        document.getElementById('shape-name').innerText = type;
        const positions = [];
        const colors = [];
        const colorScale = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;
            
            // MATH FOR SHAPES
            if (type === 'Sphere') {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 8;
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
                colorScale.setHSL(0.6 + Math.random()*0.1, 1, 0.5); // Blue/Cyan
            } 
            else if (type === 'Heart') {
                // Heart Parametric Equation
                const t = Math.random() * Math.PI * 2;
                const u = Math.random() * Math.PI; // slice
                // Simplified heart volume approximation
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random() - 0.5) * 4; // Thickness
                // Scale down
                x *= 0.5; y *= 0.5;
                colorScale.setHSL(0.95, 1, 0.5); // Red
            }
            else if (type === 'Saturn') {
                const r = Math.random();
                if (r < 0.6) {
                    // Planet
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const rad = 4;
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                    colorScale.setHSL(0.1, 1, 0.5); // Gold/Orange
                } else {
                    // Rings
                    const theta = Math.random() * Math.PI * 2;
                    const rad = 6 + Math.random() * 4;
                    x = rad * Math.cos(theta);
                    z = rad * Math.sin(theta);
                    y = (Math.random() - 0.5) * 0.5; // Thin ring
                    
                    // Rotate ring for effect
                    let tx = x, ty = y, tz = z;
                    x = tx * Math.cos(0.4) - ty * Math.sin(0.4);
                    y = tx * Math.sin(0.4) + ty * Math.cos(0.4);

                    colorScale.setHSL(0.6, 0.8, 0.8); // Light Blue Rings
                }
            }
            else if (type === 'Flower') {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 * Math.cos(3 * u); // Petals
                x = r * Math.cos(u) * Math.sin(v);
                y = r * Math.sin(u) * Math.sin(v);
                z = 2 * Math.cos(v);
                colorScale.setHSL(Math.random(), 1, 0.6); // Rainbow
            }
            else if (type === 'Twist') {
                const t = (i / PARTICLE_COUNT) * Math.PI * 20;
                x = Math.cos(t) * (2 + t/10);
                y = (i / PARTICLE_COUNT) * 20 - 10;
                z = Math.sin(t) * (2 + t/10);
                colorScale.setHSL(0.3, 1, 0.5); // Green
            }

            positions.push(x, y, z);
            colors.push(colorScale.r, colorScale.g, colorScale.b);
        }

        // Update target positions (for lerping)
        targetPositions = positions;
        
        // Update Colors immediately
        geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
    }

    // --- MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('video-feed');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandDetected = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. Get Coordinates (Index Tip) normalized 0-1
            // Invert X because camera is mirrored
            let x = 1 - landmarks[8].x; 
            let y = landmarks[8].y;
            
            // Map to Three.js World Coords (approximate)
            // Screen is roughly -15 to +15 in X, -10 to +10 in Y at z=0
            handPosition.x = (x - 0.5) * 30;
            handPosition.y = -(y - 0.5) * 20; // Invert Y for 3D space
            
            // 2. Gesture Detection (Simple Open vs Fist)
            // Check distance between Index Tip (8) and Wrist (0)
            const tip = landmarks[8];
            const wrist = landmarks[0];
            const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));

            // Heuristic: If finger is close to wrist, it's a fist/pinch
            if (dist < 0.3) {
                if (!isFist) {
                    isFist = true;
                    // Trigger Shape Switch on Fist clench
                    currentShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
                    setShape(SHAPES[currentShapeIndex]);
                }
            } else {
                isFist = false;
            }

        } else {
            isHandDetected = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    // --- MAIN ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        const positions = geometry.attributes.position.array;
        
        // Time factor for noise
        const time = Date.now() * 0.001;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let px = positions[i * 3];
            let py = positions[i * 3 + 1];
            let pz = positions[i * 3 + 2];

            let tx = targetPositions[i * 3];
            let ty = targetPositions[i * 3 + 1];
            let tz = targetPositions[i * 3 + 2];

            // --- BEHAVIOR LOGIC ---
            
            if (isHandDetected) {
                // Add Hand Interaction offset
                // If Open Hand: "Explode" / Expand particles outward from hand center
                if (!isFist) {
                    // Mild attraction to hand, but with noise
                    tx += handPosition.x;
                    ty += handPosition.y;
                    
                    // Add "Explosion" noise
                    tx += Math.sin(time + i) * 2;
                    ty += Math.cos(time + i) * 2;
                    tz += Math.sin(time * 2 + i) * 2;
                } 
                else {
                    // Fist: Tight formation at hand location
                    tx += handPosition.x;
                    ty += handPosition.y;
                }
            } else {
                // Idle animation (rotate entire shape slowly)
                const cosT = Math.cos(time * 0.1);
                const sinT = Math.sin(time * 0.1);
                // Simple rotation matrix logic applied to target
                let rx = tx * cosT - tz * sinT;
                let rz = tx * sinT + tz * cosT;
                tx = rx; tz = rz;
            }

            // LERP: Move current pos towards target
            // If Fist (Collapse): Fast Lerp. If Open (Expand): Slow Lerp/Floaty.
            const speed = isFist ? 0.1 : 0.03;

            positions[i * 3]     += (tx - px) * speed;
            positions[i * 3 + 1] += (ty - py) * speed;
            positions[i * 3 + 2] += (tz - pz) * speed;
        }

        geometry.attributes.position.needsUpdate = true;
        
        // Rotate the whole system slightly for depth perception
        particles.rotation.y += 0.002;

        renderer.render(scene, camera);
    }

    // Start
    initThree();
    animate();

</script>
</body>
</html>